from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from numbers import Rational as _Rational
    from typing import Any, overload

    from typing_extensions import Self

    from .enums import TieBreaking
    from .integer import Int

    class Fraction:
        @property
        def denominator(self, /) -> Int: ...

        @property
        def numerator(self, /) -> Int: ...

        def round(self, tie_breaking: TieBreaking, /) -> Int: ...

        @overload
        def __new__(
            cls, value: Self | Int | _Rational | float | int = ..., /
        ) -> Self: ...

        @overload
        def __new__(
            cls, numerator: Int | int, denominator: Int | int, /
        ) -> Self: ...

        def __new__(
            cls,
            numerator: Self | Int | _Rational | float | int = ...,
            denominator: Int | int = ...,
            /,
        ) -> Self: ...

        def __abs__(self, /) -> Self: ...

        def __add__(self, other: Self | Int | int, /) -> Self: ...

        def __bool__(self, /) -> bool: ...

        def __ceil__(self, /) -> Int: ...

        def __divmod__(
            self, divisor: Self | Int | int, /
        ) -> tuple[Int, Self]: ...

        @overload
        def __eq__(self, other: Self | Int | int, /) -> bool: ...

        @overload
        def __eq__(self, other: Any, /) -> Any: ...

        def __eq__(self, other: Any, /) -> Any: ...

        def __float__(self, /) -> float: ...

        def __floor__(self, /) -> Int: ...

        def __floordiv__(self, divisor: Self | Int | int, /) -> Int: ...

        def __ge__(self, other: Self | Int | int, /) -> bool: ...

        def __gt__(self, other: Self | Int | int, /) -> bool: ...

        def __hash__(self, /) -> int: ...

        def __le__(self, other: Self | Int | int, /) -> bool: ...

        def __lt__(self, other: Self | Int | int, /) -> bool: ...

        def __mod__(self, divisor: Self | Int | int, /) -> Self: ...

        def __mul__(self, other: Self | Int | int, /) -> Self: ...

        def __neg__(self, /) -> Self: ...

        def __pos__(self, /) -> Self: ...

        def __pow__(
            self, exponent: Int | int, divisor: None = ..., /
        ) -> Self: ...

        def __radd__(self, other: Int | int, /) -> Self: ...

        def __rdivmod__(self, dividend: Int | int, /) -> tuple[Int, Self]: ...

        def __reduce__(self, /) -> tuple[tuple[Self], tuple[Int, Int]]: ...

        def __repr__(self, /) -> str: ...

        def __rfloordiv__(self, dividend: Int | int, /) -> Int: ...

        def __rmod__(self, dividend: Int | int, /) -> Self: ...

        def __rmul__(self, other: Int | int, /) -> Self: ...

        @overload
        def __round__(self, digits: None = ..., /) -> Int: ...

        @overload
        def __round__(self, digits: int, /) -> Self: ...

        def __round__(self, digits: int | None = ..., /) -> Self | Int: ...

        def __rsub__(self, subtrahend: Int | int, /) -> Self: ...

        def __str__(self, /) -> str: ...

        def __sub__(self, minuend: Self | Int | int, /) -> Self: ...

        def __rtruediv__(self, dividend: Int | int, /) -> Self: ...

        def __truediv__(self, divisor: Self | Int | int, /) -> Self: ...

        def __trunc__(self, /) -> Int: ...

else:
    try:
        from . import _crithm as _module
    except ImportError:
        from . import _rithm as _module

    Fraction = _module.Fraction

    del _module
